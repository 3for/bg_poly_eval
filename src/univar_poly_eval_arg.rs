use amcl_wrapper::field_elem::{FieldElement, FieldElementVector};
use amcl_wrapper::univar_poly::UnivarPolynomial;
use amcl_wrapper::group_elem::GroupElement;
use amcl_wrapper::group_elem_g1::{G1, G1Vector};
use amcl_wrapper::commitment::commit_to_field_element;
use std::iter;
use rayon::prelude::*;
use crate::rayon::iter::IntoParallelRefMutIterator;

/// Commitment key generated by random oracle. Generates g, h. These are known to both prover and verifier.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CommitmentKey {
    /// `g` is used for the value
    pub g: G1,
    /// `h` is used for blinding
    pub h: G1,
}

impl CommitmentKey {
    // TODO: CommitmentKey can maintain lookup tables for small multiples of `g` and `h` to speed up exponentiation

    pub fn new(label: &[u8]) -> Self {
        let g = G1::from_msg_hash(&[label, " : g".as_bytes()].concat());
        let h = G1::from_msg_hash(&[label, " : h".as_bytes()].concat());
        Self { g, h }
    }

    /// Commit to `val` with blinding as `blinding`
    pub fn commit(&self, val: &FieldElement, blinding: &FieldElement) -> G1 {
        commit_to_field_element(&self.g, &self.h, val, blinding)
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = vec![];
        bytes.append(&mut self.g.to_bytes());
        bytes.append(&mut self.h.to_bytes());
        bytes
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UnivarPolyEvalArgProtocol {
    /// `u` is the variable at which the polynomial is evaluated
    u: FieldElement,
    /// Blinding used when committing to u.
    r_0: FieldElement,
    /// Commitment to `u`
    comm_u: G1,
    /// `v` is the result of evaluating the polynomial
    v: FieldElement,
    /// Blinding used when committing to v.
    t: FieldElement,
    /// Commitment to `v`
    comm_v: G1,
    /// Even powers of u. [u^{2^1}, u^{2^2}, u^{2^3}, ...u^{2^d}]
    even_powers_u: Vec<FieldElement>,
    /// Blindings used when committing to even powers of u.
    r: Vec<FieldElement>,
    /// commitments to even power of u
    comm_even_powers_u: Vec<G1>,
    /// `f` is the additive blinding of powers of u in Q(x)
    f: Vec<FieldElement>,
    /// `s` is the blinding used to commit `f`
    s: Vec<FieldElement>,
    /// commitments to `f`
    comm_f: Vec<G1>,
    blindings_delta: Vec<FieldElement>,
    /// commitments to `delta`
    comm_delta: Vec<G1>,
    xi: Vec<FieldElement>,
    /// commitments to `f_j^{u^{2^j}}`
    comm_f_times_u_power: Vec<G1>
}

/// This serves as the proof that evaluating polynomial at u gives v. Commitments to u and v are
/// intentionally omitted as the verifier should receive them independently of the prover.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UnivarPolyEvalArg {
    /// commitments to even power of u
    comm_even_powers_u: Vec<G1>,
    /// commitments to `f`
    comm_f: Vec<G1>,
    /// commitments to `delta`
    comm_delta: Vec<G1>,
    /// commitments to `f_j^{u^{2^j}}`
    comm_f_times_u_power: Vec<G1>,
    f_bar: Vec<FieldElement>,
    r_bar: Vec<FieldElement>,
    t_bar: FieldElement,
    xi_bar: Vec<FieldElement>,
}

macro_rules! challenge_bytes {
    ( $self:ident, $poly:ident, $comm_variable:expr, $comm_evaluation:expr, $comm_key:ident ) => {
        {
            let mut bytes = vec![];
            for coeff in $poly.coefficients().iter() {
                bytes.append(&mut coeff.to_bytes())
            }
            bytes.append(&mut $comm_variable.to_bytes());
            bytes.append(&mut $comm_evaluation.to_bytes());
            bytes.append(&mut $comm_key.to_bytes());
            for com in $self.comm_even_powers_u.iter() {
                bytes.append(&mut com.to_bytes())
            }
            for com in $self.comm_f.iter() {
                bytes.append(&mut com.to_bytes())
            }
            for com in $self.comm_delta.iter() {
                bytes.append(&mut com.to_bytes())
            }
            for com in $self.comm_f_times_u_power.iter() {
                bytes.append(&mut com.to_bytes())
            }
            bytes
        }
    };
}

impl UnivarPolyEvalArgProtocol {
    // TODO: Make both init functions accept a PRNG and use it for testing with small numbers

    /// `variable` corresponds to `u` and `evaluation` corresponds to `v` in the paper
    pub fn init(poly: &UnivarPolynomial, variable: FieldElement, evaluation: FieldElement, comm_key: &CommitmentKey) -> UnivarPolyEvalArgProtocol {
        let blinding_variable = FieldElement::random();
        let blinding_evaluation = FieldElement::random();
        let comm_variable = comm_key.commit(&variable, &blinding_variable);
        let comm_evaluation = comm_key.commit(&evaluation, &blinding_evaluation);
        Self::init_with_given_commitments(poly, variable, evaluation, blinding_variable, blinding_evaluation, comm_variable, comm_evaluation, comm_key)
    }

    /// `variable` corresponds to `u` and `evaluation` corresponds to `v` in the paper
    pub fn init_with_given_commitments(poly: &UnivarPolynomial, variable: FieldElement, evaluation: FieldElement, blinding_variable: FieldElement, blinding_evaluation: FieldElement, comm_variable: G1, comm_evaluation: G1, comm_key: &CommitmentKey) -> UnivarPolyEvalArgProtocol {
        let d = Self::check_poly_degree_and_return_log_degree(&poly);

        // TODO: Parallelize the following code with rayon

        // XXX: This can be made faster since commitments are being made to powers of same element
        // even_powers_u = [variable^{2^1}, variable^{2^2}, variable^{2^3}, ...variable^{2^d}]
        let mut even_powers_u = if d > 0 {
            vec![variable.square()]
        } else {
            vec![]
        };
        for i in 1..d {
            even_powers_u.push(even_powers_u[(i-1) as usize].square())
        }
        // blindings for committing to even_powers_u
        let blindings_even_powers_u: Vec<FieldElement> = FieldElementVector::random(d as usize).into();
        // comm_even_powers_u are commitments to even power of u
        let comm_even_powers_u = even_powers_u.as_slice().par_iter().zip(blindings_even_powers_u.as_slice().par_iter()).map(|(u_i, r_i)| comm_key.commit(u_i, r_i)).collect::<Vec<G1>>();

        // `f` is the additive blinding of powers of u in Q(x), `s` is the blinding used to commit `f`.
        // There are d+1 elements in `f`, 1 for `u` and 1 for each ever power of `u`
        let f: Vec<FieldElement> = FieldElementVector::random(d as usize + 1).into();
        let s: Vec<FieldElement> = FieldElementVector::random(d as usize + 1).into();
        let comm_f = f.as_slice().par_iter().zip(s.as_slice().par_iter()).map(|(f_i, s_i)| comm_key.commit(f_i, s_i)).collect::<Vec<G1>>();

        // u_raised_to_powers_of_2 = [variable, variable^{2^1}, variable^{2^2}, variable^{2^3}, ...variable^{2^d}]
        let mut u_raised_to_powers_of_2 = vec![&variable];
        for i in 0..d {
            u_raised_to_powers_of_2.push(&even_powers_u[i as usize])
        }

        let poly_Q = Self::get_poly_Q(&poly, d as usize, &u_raised_to_powers_of_2, &f);
        let delta: Vec<FieldElement> = poly_Q.0.into();
        let blindings_delta: Vec<FieldElement> = FieldElementVector::random(d as usize + 1).into();
        let comm_delta = delta.as_slice().par_iter().zip(blindings_delta.as_slice().par_iter()).map(|(d_i, e_i)| comm_key.commit(d_i, e_i)).collect::<Vec<G1>>();

        // `f_times_u_power` is f_i * u^{2^i}
        let mut f_times_u_power = vec![];
        for i in 0..d {
            f_times_u_power.push(&f[i as usize] * u_raised_to_powers_of_2[i as usize]);
        }
        // `blindings_f_times_u` is called `xi` in the paper
        let blindings_f_times_u: Vec<FieldElement> = FieldElementVector::random(d as usize).into();
        let comm_f_times_u_power = f_times_u_power.as_slice().par_iter().zip(blindings_f_times_u.as_slice().par_iter()).map(|(f_u_i, e_i)| comm_key.commit(f_u_i, e_i)).collect::<Vec<G1>>();
        UnivarPolyEvalArgProtocol {
            u: variable, r_0: blinding_variable, comm_u: comm_variable,
            v: evaluation, t: blinding_evaluation, comm_v: comm_evaluation,
            even_powers_u, r: blindings_even_powers_u, comm_even_powers_u,
            f, s, comm_f, blindings_delta, comm_delta,
            xi: blindings_f_times_u,
            comm_f_times_u_power
        }
    }

    pub fn get_bytes_for_challenge(&self, poly: &UnivarPolynomial, comm_key: &CommitmentKey) -> Vec<u8> {
        challenge_bytes!(self, poly, &self.comm_u, &self.comm_v, comm_key)
    }

    pub fn respond(self, challenge: &FieldElement) -> UnivarPolyEvalArg {
        // The paper denotes the challenge by `x`

        let d = self.even_powers_u.len();
        // u_raised_to_powers_of_2 = [u, u^{2^1}, u^{2^2}, u^{2^3}, ...u^{2^d}]
        let mut u_raised_to_powers_of_2 = vec![&self.u];
        for i in 0..d {
            u_raised_to_powers_of_2.push(&self.even_powers_u[i as usize])
        }

        // {f_bar}_j = x*u^{2^j} + f_j for j in [0, d]
        let f_bar = u_raised_to_powers_of_2.as_slice().par_iter().zip(self.f.as_slice().par_iter()).map(|(u_i, f_i)|((challenge * *u_i) + f_i)).collect::<Vec<FieldElement>>();

        // r is [r_0, r_1, r_2, ... r_d]
        let r = iter::once(self.r_0).chain(self.r.into_iter()).collect::<Vec<FieldElement>>();
        // r_bar_j = x*r_j + s_j for j in [0, d]
        let r_bar = r.par_iter().zip(self.s.par_iter()).map(|(r_i, s_i)|((challenge * r_i) + s_i)).collect::<Vec<FieldElement>>();

        // x_powers is [1, x, x^2, x^3, ...., x^{d+1}]
        let x_powers = FieldElementVector::new_vandermonde_vector(challenge, d+2);
        // t = [t_0, t_1, t_2, ... t]
        let t = self.blindings_delta.into_iter().chain(iter::once(self.t)).collect::<Vec<FieldElement>>();
        // t_bar = sum of (x^j * t_j) for d in [0, d+1] which is same as taking inner product of x_powers and t
        let t_bar = x_powers.inner_product(&FieldElementVector::from(t)).unwrap();

        // {xi_bar}_j = x*r_{j+1} - {{f_bar}_j * r_j} + xi_j for j in [0, d-1]
        let xi_bar = self.xi.as_slice().par_iter().enumerate().map(|(j, xi)| &(challenge * &r[j+1]) - &(&f_bar[j] * &r[j]) + xi).collect::<Vec<FieldElement>>();

        UnivarPolyEvalArg {
            comm_even_powers_u: self.comm_even_powers_u,
            comm_f: self.comm_f,
            comm_delta: self.comm_delta,
            comm_f_times_u_power: self.comm_f_times_u_power,
            f_bar, r_bar, t_bar, xi_bar
        }
    }

    pub fn variable(&self) -> &FieldElement {
        &self.u
    }

    pub fn evaluation(&self) -> &FieldElement {
        &self.v
    }

    pub fn blinding_variable(&self) -> &FieldElement {
        &self.r_0
    }

    pub fn blinding_evaluation(&self) -> &FieldElement {
        &self.t
    }

    pub fn comm_variable(&self) -> &G1 {
        &self.comm_u
    }

    pub fn comm_evaluation(&self) -> &G1 {
        &self.comm_v
    }

    /// Check whether degree is a power of two and return log_2(degree)
    // TODO: Remove this restriction
    pub fn check_poly_degree_and_return_log_degree(poly: &UnivarPolynomial) -> u32 {
        let degree = poly.degree();
        assert!(degree > 0);
        assert!(degree.is_power_of_two());
        degree.trailing_zeros()
    }

    /// The returned Q polynomial does not have the X^{d+1} degree term
    fn get_poly_Q(poly_P: &UnivarPolynomial, d: usize, u_raised_to_powers_of_2: &[&FieldElement], f: &[FieldElement]) -> UnivarPolynomial {
        assert_eq!(u_raised_to_powers_of_2.len(), d+1);
        assert_eq!(f.len(), d+1);

        // 2^d
        let two_raised_to_d = 1 << d;
        // poly_Q_terms will hold terms of a polynomial Q(X)
        let mut poly_Q_terms = Vec::with_capacity(two_raised_to_d+1);

        // Add polynomial for a_{2^d}
        let mut poly_2_d = UnivarPolynomial::new(d + 1);
        poly_2_d[d] = f[d].clone();
        poly_2_d[d+1] = u_raised_to_powers_of_2[d].clone();
        poly_Q_terms.push(poly_2_d);

        // TODO: This is executed in a binary tree fashion and each branch can be processed in parallel.
        for i in (0..two_raised_to_d).rev() {
            let mut poly_i = UnivarPolynomial::new(d + 1);
            poly_i[1] = FieldElement::one();
            for j in (0..d).rev() {
                if ((i >> j) & 1) == 1 {
                    // If MSB of i is 1, multiply by (X*u^{2^j} + f_j)
                    let mut factor = UnivarPolynomial::new(1);
                    factor[0] = f[j].clone();
                    factor[1] = u_raised_to_powers_of_2[j].clone();
                    poly_i = UnivarPolynomial::multiply(&poly_i, &factor);
                } else {
                    // If MSB of i is 0, multiply by X
                    poly_i = poly_i.multiply_by_monic_monomial(1);
                }
            }
            poly_Q_terms.push(poly_i);
        }
        assert_eq!(poly_Q_terms.len(), poly_P.degree()+1);

        poly_Q_terms.reverse();

        // Multiply each of poly_Q_terms with a_i and then add all terms of poly_Q_terms to get poly_Q
        poly_Q_terms
            .as_mut_slice()
            .par_iter_mut()
            .enumerate()
            .for_each(|(i, p)| *p = p.multiply_by_constant(&poly_P[i]));

        poly_Q_terms.as_slice()
            .par_iter()
            .cloned()
            .reduce(|| UnivarPolynomial::new(d), |sum, p| &sum + &p)
    }
}

impl UnivarPolyEvalArg {
    pub fn get_bytes_for_challenge(&self, poly: &UnivarPolynomial, comm_variable: &G1, comm_evaluation: &G1, comm_key: &CommitmentKey) -> Vec<u8> {
        challenge_bytes!(self, poly, comm_variable, comm_evaluation, comm_key)
    }

    pub fn verify(&self, challenge: &FieldElement, poly: &UnivarPolynomial, comm_variable: &G1, comm_evaluation: &G1, comm_key: &CommitmentKey) -> bool {
        // The paper denotes the challenge by `x`

        let d = UnivarPolyEvalArgProtocol::check_poly_degree_and_return_log_degree(&poly);

        // TODO: Check the size of each list of commitments and responses to ensure that they are of appropriate size

        // TODO: Parallelize the following code with rayon

        // The need for these 2 is explained below
        // TODO: Since these are 2 are used several times in multi-scalar multiplication, its better
        // to compute lookup tables for them once.
        let g_inv = comm_key.g.negation();
        let h_inv = comm_key.h.negation();

        let mut comm_u_raised_to_powers_of_2 = vec![comm_variable];
        for i in 0..d {
            comm_u_raised_to_powers_of_2.push(&self.comm_even_powers_u[i as usize])
        }

        // check {c_j}^x * c_{f_j} == commitment({f_bar}_j; {r_bar}_j) = g^{{f_bar}_j} * h^{{r_bar}_j}
        // to use multi-scalar multi-exp, i can check {c_j}^x * c_{f_j} * g^{-{f_bar}_j} * h^{-{r_bar}_j} == 1
        // Now rather than negating each exponent, its better to invert g and h once, so that the
        // check becomes {c_j}^x * c_{f_j} * {1/g}^{{f_bar}_j} * {1/h}^{{r_bar}_j} == 1
        // check {c_j}^x * c_{f_j} * {1/g}^{{f_bar}_j} * {1/h}^{{r_bar}_j} == 1 for j in [0, d]
        for j in 0..=d as usize {
            if !G1Vector::multi_scalar_mul_var_time_without_precomputation(
                iter::once(comm_u_raised_to_powers_of_2[j]).
                    chain(iter::once(&self.comm_f[j])).
                    chain(iter::once(&g_inv)).
                    chain(iter::once(&h_inv)),
                iter::once(challenge).
                    chain(iter::once(&FieldElement::one())).
                    chain(iter::once(&self.f_bar[j])).
                    chain(iter::once(&self.r_bar[j]))
            ).unwrap().is_identity() {
                return false
            }
        }

        // check {c_{j+1}}^x * c_j^{-{{f_bar}_j}} * c_{f_{u_j}} == commitment(0; {xi_bar}_j) = g^0 * h^{{xi_bar}_j}
        // to use multi-scalar multi-exp, i can check {c_{j+1}}^x * c_j^{-{{f_bar}_j}} * c_{f_{u_j}} * h^{-{xi_bar}_j} == 1
        // Rather than negating each exponent, its better to use inverted h, so that the check
        // becomes {c_{j+1}}^x * c_j^{-{{f_bar}_j}} * c_{f_{u_j}} * {1/h}^{-{xi_bar}_j} == 1

        // check {c_{j+1}}^x * c_j^{-{{f_bar}_j}} * c_{f_{u_j}} * {1/h}^{-{xi_bar}_j} == 1 for j in [0, d)
        for j in 0..d as usize {
            if !G1Vector::multi_scalar_mul_var_time_without_precomputation(
                iter::once(comm_u_raised_to_powers_of_2[j +1]).
                    chain(iter::once(comm_u_raised_to_powers_of_2[j])).
                    chain(iter::once(&self.comm_f_times_u_power[j])).
                    chain(iter::once(&h_inv)),
                iter::once(challenge).
                    chain(iter::once(&(-&self.f_bar[j]))).
                    chain(iter::once(&FieldElement::one())).
                    chain(iter::once(&self.xi_bar[j]))
            ).unwrap().is_identity() {
                return false
            }
        }

        // check {c_v}^{x^{d+1}} * { {c_{delta_j}}^{x^j} for all j in [0, d] } == commitment(delta_bar, t_bar)
        // which is same as checking {c_v}^{x^{d+1}} * { {c_{delta_j}}^{x^j} for all j in [0, d] } * {1/g}^delta_bar * {1/h}^t_bar == 1

        let delta_bar = Self::calculate_delta_bar(&poly, d as usize, challenge, &self.f_bar);
        // x_powers is [1, x, x^2, x^3, ...., x^{d+1}]
        let x_powers = FieldElementVector::new_vandermonde_vector(challenge, d as usize + 2);

        // Prepare for multi-exp
        // group_elems is [c_delta_0, c_delta_1, c_delta_2, ..., c_delta_d, c_v, 1/g, 1/h]
        let group_elems = self.comm_delta.iter().
            chain(iter::once(comm_evaluation)).
            chain(iter::once(&g_inv)).
            chain(iter::once(&h_inv));

        // field_elems is [1, x, x^2, x^3, ...., x^{d+1}, delta_bar, t_bar]
        let field_elems = x_powers.iter().
            chain(iter::once(&delta_bar)).
            chain(iter::once(&self.t_bar));

        if !G1Vector::multi_scalar_mul_var_time_without_precomputation(group_elems, field_elems).unwrap().is_identity() {
            return false
        }

        true
    }

    fn calculate_delta_bar(poly_P: &UnivarPolynomial, d: usize, x: &FieldElement, f_bar: &[FieldElement]) -> FieldElement {
        assert_eq!(f_bar.len(), d+1);

        // 2^d
        let two_raised_to_d = 1 << d;
        let mut delta_bar_terms = Vec::with_capacity(two_raised_to_d+1);

        // Add polynomial for a_{2^d}
        let mut poly_2_d = UnivarPolynomial::new(d);
        poly_2_d[d] = f_bar[d].clone();
        delta_bar_terms.push(poly_2_d);

        // TODO: This is executed in a binary tree fashion and each branch can be processed in parallel.
        for i in (0..two_raised_to_d).rev() {
            let mut poly_i = UnivarPolynomial::new(d+1);
            poly_i[1] = FieldElement::one();
            for j in (0..d).rev() {
                if ((i >> j) & 1) == 1 {
                    // If MSB of i is 1, multiply by f_bar[j]
                    poly_i = poly_i.multiply_by_constant(&f_bar[j]);
                } else {
                    // If MSB of i is 0, multiply by X
                    poly_i = poly_i.multiply_by_monic_monomial(1);
                }
            }
            delta_bar_terms.push(poly_i);
        }

        assert_eq!(delta_bar_terms.len(), poly_P.degree()+1);

        delta_bar_terms.reverse();

        // Multiply each of delta_bar_terms with a_i and then add all terms of delta_bar_terms to get delta_bar polynomial
        delta_bar_terms
            .as_mut_slice()
            .par_iter_mut()
            .enumerate()
            .for_each(|(i, p)| *p = p.multiply_by_constant(&poly_P[i]));

        let delta_bar_poly = delta_bar_terms.as_slice()
            .par_iter()
            .cloned()
            .reduce(|| UnivarPolynomial::new(d), |sum, p| &sum + &p);

        // Evaluate delta_bar polynomial at x
        delta_bar_poly.eval(x)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::{Duration, Instant};

    #[test]
    fn test_prove_evaluation() {
        let comm_key = CommitmentKey::new("test".as_bytes());

        for degree in vec![1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024] {
            let poly = UnivarPolynomial::random(degree);
            let u = FieldElement::random();
            let v = poly.eval(&u);

            let start_prover = Instant::now();

            let protocol = UnivarPolyEvalArgProtocol::init(&poly, u, v, &comm_key);
            let c_0 = protocol.comm_variable().clone();
            let c_v = protocol.comm_evaluation().clone();

            let challenge_by_prover = FieldElement::from_msg_hash(&protocol.get_bytes_for_challenge(&poly, &comm_key));

            let zk_argument = protocol.respond(&challenge_by_prover);

            let prover_time = start_prover.elapsed();

            let start_verifier = Instant::now();

            let challenge_by_verifier = FieldElement::from_msg_hash(&zk_argument.get_bytes_for_challenge(&poly, &c_0, &c_v, &comm_key));

            assert_eq!(challenge_by_prover, challenge_by_verifier);

            assert!(zk_argument.verify(&challenge_by_verifier, &poly, &c_0, &c_v, &comm_key));

            let verifier_time = start_verifier.elapsed();

            println!("For degree {}, proving time is {:?} and verification time is {:?}", degree, prover_time, verifier_time);
        }
    }
}